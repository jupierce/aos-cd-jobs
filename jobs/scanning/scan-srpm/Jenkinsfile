

node('covscan') {
    checkout scm
    def buildlib = load("pipeline-scripts/buildlib.groovy")
    def commonlib = buildlib.commonlib
    def slacklib = commonlib.slacklib

    properties(
        [
            buildDiscarder(
                logRotator(
                    artifactDaysToKeepStr: '',
                    artifactNumToKeepStr: '',
                    daysToKeepStr: '365',
                )
            ),
            [
                $class : 'ParametersDefinitionProperty',
                parameterDefinitions: [
                    commonlib.ocpVersionParam('BUILD_VERSION'),
                    /*string(
                        name: 'NVRA',
                        description: 'The brew nvr for the srpm. e.g. openshift-clients-4.3.3-202002192116.git.1.18d8f2b.el7',
                        trim: false
                    ),*/
                    string(
                        name: 'BREW_TASK_ID',
                        description: 'Brew build task for the RPM',
                        trime: true,
                    ),
                    booleanParam(   defaultValue: false,
                                    description: 'Force a rescan of the codebase even if it was already performed',
                                    name: 'RE_SCAN'),
                    booleanParam(   defaultValue: false,
                                    description: 'Force re-prompting for waiver information',
                                    name: 'RE_WAIVE'),
                    booleanParam(   defaultValue: false,
                                    description: 'If true, waivers from previous commits will not be used to determine issues (i.e. all issues will be reported).',
                                    name: 'IGNORE_PREVIOUS'),
                    commonlib.mockParam(),
                ],
            ],
        ]
    )

    commonlib.checkMock()

    timestamps {

        def (major, minor) = commonlib.extractMajorMinorVersionNumbers(BUILD_VERSION)
        def imageName = "golang-scanner-${BUILD_VERSION}"

        slackChannel = slacklib.to(BUILD_VERSION)

        sshagent(['openshift-bot']) {

            RUN_DATE = sh(returnStdout: true, script:'date "+%s"')
            WORK_COV = "${env.WORKSPACE}/cov"
            WORK_RPM = "${env.WORKSPACE}/rpm"

            NVRA = null
            BUILD_TAG = null
            BREW_TASK_INFO = sh(returnStdout: true, script:"brew taskinfo ${BREW_TASK_ID} -rv")
            for ( String taskLine: BREW_TASK_INFO.split() ) {
                taskLine = taskLine.trim()

                // Look for a line like: SRPM: /mnt/redhat/brewroot/work/tasks/4600/27044600/openshift-clients-4.5.0-202003050701.git.0.06478dc.el7.src.rpm
                if ( taskLine.startsWith('SRPM: ') ) {
                    echo "Extracting NVRA from ${taskLine}"
                    NVRA = taskLine.split('/')[-1].split('.src')[0]
                    continue
                }

                // Look for a line like: Build Tag: rhaos-4.5-rhel-7-build
                if ( taskLine.startsWith('Build Tag: ') ) {
                    BUILD_TAG = taskLine.split(':')[1].trim()
                }
            }

            if ( NVRA == null || BUILD_TAG == null ) {
                error("I could not find NVRA or BUILD_TAG in taskinfo for ${BREW_TASK_ID}:\n${BREW_TASK_INFO}")
            }

            if (BUILD_TAG.contains('-rhel-7-')) {
                MOCK_PROFILE = readFile(file: 'jobs/scanning/scan-srpm/base-rhel-7-mock-profile.cfg')
            } else {
                // More profiles can be found here: https://gitlab.cee.redhat.com/covscan/mock-profiles/tree/master/src
                error("I don't have a profile yet for for ${BUILD_TAG}")
            }

            // Update the mock profile to contain the buildroot repo used by the task
            MOCK_PROFILE = MOCK_PROFILE.replace('#PIPELINE_INJECT_REPOS#', """
[${BUILD_TAG}]
name=${BUILD_TAG}
gpgcheck=0
baseurl=http://download.eng.bos.redhat.com/brewroot/repos/${BUILD_TAG}/latest/x86_64/
priority=255
""")

            // Example output: /mnt/redhat/brewroot/vol/rhel-7/packages/openshift-clients/4.3.3/202002192116.git.1.18d8f2b.el7/src/openshift-clients-4.3.3-202002192116.git.1.18d8f2b.el7.src.rpm
            NFS_SRPM_PATH = sh(returnStdout: true, script:"brew buildinfo ${NVRA} | grep src.rpm").trim()
            SRPM_FILENAME = sh(returnStdout: true, script:"basename ${NFS_SRPM_PATH}").trim()
            (SRPM_N, SRPM_V, SRPM_R, SRPM_A) = sh(returnStdout: true, script:"rpm -qp --queryformat '%{NAME} %{VERSION} %{RELEASE} %{ARCH}' ${NFS_SRPM_PATH}").split()

            sh """
            set -euxo pipefail
            rm -rf ${WORK_COV} ${WORK_RPM}
            mkdir -p ${WORK_COV} ${WORK_RPM}
            cp ${NFS_SRPM_PATH} ${WORK_RPM}
            """

            currentBuild.displayName = "${currentBuild.displayName} - ${BREW_TASK_ID}: ${SRPM_FILENAME}"

            SCANS_BASE_DIR = '/mnt/nfs/coverity/scans'
            NVR="${SRPM_N}-${SRPM_V}-{SRPM_R}"

            NVR_SCAN_DIR = "${SCANS_BASE_DIR}/${NVR}"  // presence indicates a scan has been performed
            WAIVED_BASE_DIR = '/mnt/nfs/coverity/waived'
            NVR_WAIVED_DIR = "${WAIVED_BASE_DIR}/${NVR}"  // presence indicates issues have been waived

            stage('scan') {
                sh "mkdir -p ${SCANS_BASE_DIR}"
                sh "mkdir -p ${WAIVED_BASE_DIR}"

                if ( fileExists("${NVR_SCAN_DIR}")) {
                    if ( params.RE_SCAN ) {
                        sh "rm -rf ${NVR_SCAN_DIR} ${NVR_WAIVED_DIR}"
                    } else {
                        echo "Detected ${NVR_SCAN_DIR} . Scan has already been performed. Skipping ."
                        return // jump to the end of the stage
                    }
                }

                imageName = "golang-scanner-${BUILD_VERSION}"

                sh """
                set -euxo pipefail
                sudo podman run --privileged -u `id -u`:`id -g` -t --rm -v ${WORK_RPM}:/rpm -v ${WORK_COV}:/cov ${imageName} /bin/sh -c 'export PATH=\$PATH:/opt/coverity/bin; csmock -o /cov -t cppcheck,gcc,shellcheck,clang,coverity --cov-analyze-java --cov-analyze-opts='--security --concurrency' --use-host-cppcheck --cov-use-version cov-sa-2019.12 /rpm/${SRPM_FILENAME}'

                # a profile with a yum repo can be retrieved for a particular task with "brew mock-config --task 27044635 --latest" where the task number is the task for the x86 build!
                # csmock -r test -t cppcheck,gcc,shellcheck,clang,coverity /rpm/SRPMFILE  # Where test.cfg is under /etc/mock/profiles

                export PATH=\$PATH:/opt/coverity/bin
                # Because the build ran in a container, the emits must be changed to come from the buildvm2 host before they can be analyzed
                cov-manage-emit --dir=./cov reset-host-name
                cov-analyze  --dir=./cov "--wait-for-license" "-co" "ASSERT_SIDE_EFFECT:macro_name_lacks:^assert_(return|se)\$" "-co" "BAD_FREE:allow_first_field:true" "--include-java" "--fb-max-mem=4096" "--security" "--concurrency" --allow-unmerged-emits
                cov-format-errors --json-output-v2 /dev/stdout --dir=./cov > ./cov/raw_results.js
                cshtml ./cov/raw_results.js > ./cov/raw_results.html

                """

                archiveArtifacts(artifacts: "cov/*_results.*")

                // Copy the scan results to the NFS. This only indicates the code has been scanned. No waiver is implied.
                sh """
                mkdir -p ${COMMIT_SCAN_DIR}
                cp cov/*_results.* ${COMMIT_SCAN_DIR}   # The full directory can be gigs, so only copy result
                """
            }


            stage('waive') {

                if ( fileExists( COMMIT_WAIVED_DIR ) && params.RE_WAIVE == false ) {
                    echo "Detected ${COMMIT_WAIVED_DIR}. Issues have already been waived. Skipping waiver input."
                    return // end the stage
                }

                sh """
                # If case we don't find anything, diff results are the same as raw results
                cp ${COMMIT_SCAN_DIR}/raw_results.js ${COMMIT_SCAN_DIR}/diff_results.js

                if [[ "${params.IGNORE_PREVIOUS}" == "false" ]]; then
                    pushd ${env.WORKSPACE}/go/src/${GO_DIR}
                    # For each of the preceding 1000 commits, skipping the HEAD commit
                    for hash in `git --no-pager log --pretty='%H' -1000 | tail -n +2`; do
                        if [[ -d "${WAIVED_BASE_DIR}/\$hash" ]]; then
                            echo "Found previous commit with waived issues: ${WAIVED_BASE_DIR}/\$hash"
                            csdiff ${COMMIT_SCAN_DIR}/raw_results.js "${WAIVED_BASE_DIR}/\$hash/raw_results.js" > ${COMMIT_SCAN_DIR}/diff_results.js
                            break
                        fi
                    done
                    popd
                fi

                cshtml ${COMMIT_SCAN_DIR}/diff_results.js > ${COMMIT_SCAN_DIR}/diff_results.html

                # We could read in this into Jenkins, but the files can be >10M, so let jq figure out if there is a diff to review
                if [[ `cat ${COMMIT_SCAN_DIR}/diff_results.js | jq '.issues | length' -r` != '0' ]]; then
                    echo "Differences detected from previous commit."
                    touch ${COMMIT_SCAN_DIR}/diff_results.flag
                else
                    rm -f ${COMMIT_SCAN_DIR}/diff_results.flag
                fi

                # Copy diffs to workspace so we can archive them
                cp ${COMMIT_SCAN_DIR}/diff_results.* ./cov

                """

                archiveArtifacts(artifacts: "cov/diff_results.*")

                sh """
                set -euxo pipefail
                scp ${COMMIT_SCAN_DIR}/raw_results.html ocp-build@rcm-guest.app.eng.bos.redhat.com:/mnt/rcm-guest/puddles/RHAOS/coverity/${REPO_COMMIT}.raw_results.html
                scp ${COMMIT_SCAN_DIR}/diff_results.html ocp-build@rcm-guest.app.eng.bos.redhat.com:/mnt/rcm-guest/puddles/RHAOS/coverity/${REPO_COMMIT}.diff_results.html
                """

                if ( ! fileExists("${COMMIT_SCAN_DIR}/diff_results.flag") ) {
                    echo "No scan differences detected from last commit. No waivers are required."
                    return // end the stage
                }

                slackChannel.task("Coverity result review: ${GIT_REPO} branch: ${GIT_BRANCH}") {
                    taskThread ->

                    taskThread.failure("[NEW SCAN WAIVERS REQUIRED] Please review results for ${GIT_REPO} commit=${REPO_COMMIT}\nDifferences from a previously waived commit: http://download.eng.bos.redhat.com/rcm-guest/puddles/RHAOS/coverity/${REPO_COMMIT}.diff_results.html")

                    commonlib.inputRequired() {
                        happy = false
                        while(!happy) {

                            def raw_results_url = "http://download.eng.bos.redhat.com/rcm-guest/puddles/RHAOS/coverity/${REPO_COMMIT}.raw_results.html"
                            def diff_results_url = "http://download.eng.bos.redhat.com/rcm-guest/puddles/RHAOS/coverity/${REPO_COMMIT}.diff_results.html"
                            echo "Waiver details are required.."

                            prompt = """Coverity has detected new issues during static analysis for ${GIT_REPO} commit=${REPO_COMMIT} .
You must review the findings with an engineering / prodsec resource before waiving these results. If the
findings must be fixed in the code (i.e. not WAIVED), then choose ABORT to stop the pipeline.

Differences from a previously waived commit: ${diff_results_url}
All issues: ${raw_results_url}
"""
                            echo prompt

                            def resp = input message: prompt,
                                submitterParameter: 'approver',
                                parameters: [
                                    [
                                        $class     : 'hudson.model.ChoiceParameterDefinition',
                                        choices    : ['WAIVE', 'ABORT'].join('\n'),
                                        description : 'WAIVE only if an engineering resource has confirmed the findings are NOT a security risk.',
                                        name       : 'action'
                                    ],
                                    string( defaultValue: '',
                                            description: 'Link to slack thread / Jira ticket / etc where the conversation about security concerns was discussed. ',
                                            name: 'conversation_url',
                                            trim: true
                                    ),
                                    text(   defaultValue: '',
                                            description: 'An overview of why these issues were waived. ',
                                            name: 'waiver_overview'
                                    ),
                                ]

                            def action = (resp instanceof String)?resp:resp.action

                            switch(action) {
                            case 'WAIVE':
                                // just fall through
                                break
                            case 'ABORT':
                                error('User chose to abort scan pipeline')
                            }

                            def waiver_details = """
Job: ${env.BUILD_URL}

Approver: ${resp.approver}

Discussion: ${resp.conversation_url}

Overview:\n${resp.waiver_overview}
"""

                            echo "The following waiver details will be recorded >>>>>>>>>>\n${waiver_details}\n<<<<<<<<<<<<"
                            echo "Confirm these details.."

                            def confirm = input message: "Are you completely sure you want to waive using the provided information?",
                                parameters: [
                                    [
                                        $class     : 'hudson.model.ChoiceParameterDefinition',
                                        choices    : ['YES', 'RE-ENTER'].join('\n'),
                                        description : 'If you want to alter your reasons, select RE-ENTER.',
                                        name       : 'action'
                                    ],
                                ]

                            def confim_action = (confirm instanceof String)?confirm:confirm.action

                            if ( confim_action == 'YES' ) {
                                currentBuild.keepLog = true  // Don't ever prune this build
                                happy = true // terminate the waiver input loop
                                writeFile( file: 'waiver.txt', text: waiver_details)

                                archiveArtifacts(artifacts: "waiver.txt")

                                sh """
                                cat waiver.txt > ${COMMIT_SCAN_DIR}/waiver.txt.`date +%s`
                                # Create the link that will consider this commit's issues waived
                                ln -sfn ${COMMIT_SCAN_DIR} ${COMMIT_WAIVED_DIR}
                                """
                            }

                        }

                    }

                }


            }

        }
    }


}